<!DOCTYPE html>
<html lang="ja">
<head>

  <!--
    Shibmap (c) 2025 katagirigouta
    License: CC BY-NC 4.0 International (https://creativecommons.org/licenses/by-nc/4.0/)
    This project is licensed for non-commercial use only.
  -->

  <meta charset="UTF-8" />
  <title>Shibmap</title>
  <link rel="manifest" href="manifest.json" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />

  <!-- Leaflet -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

  <!-- マーカークラスタ：大量件数向け -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.css" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.Default.css" />
  <script src="https://unpkg.com/leaflet.markercluster@1.5.3/dist/leaflet.markercluster.js"></script>
    <style>
    /* --- 動画プレイヤー & カードスライドUI追加 --- */
    #player {
      position: fixed;
      left: 50%;
      bottom: 90px;
      transform: translateX(-50%);
      z-index: 1010;
      width: 90vw;
      max-width: 520px;
      height: 32vw;
      max-height: 300px;
      background: #0f0f0f;
      border-radius: 16px;
      box-shadow: 0 6px 18px rgba(0,0,0,0.22);
      display: none;
    }
    /* --- Map gesture fixes & panel hit-testing --- */
    .leaflet-container { touch-action: pan-x pan-y; -ms-touch-action: pan-x pan-y; }
    /* When the input panel is collapsed off-screen, don't intercept touches */
    #inputPanel.collapsed { pointer-events: none; }
    /* Keep the floating FAB clickable even if the collapsed panel has pointer-events:none */
    #panelToggleFab { pointer-events: auto; }
    #player video {
      width: 100%;
      height: 100%;
      border-radius: 16px;
      object-fit: contain;
      background: #111;
    }
    #cardStrip {
      position: fixed;
      left: 50%;
      bottom: 16px;
      transform: translateX(-50%);
      z-index: 1011;
      display: flex;
      gap: 10px;
      overflow-x: auto;
      padding: 8px 10px;
      width: 96vw;
      max-width: 680px;
      background: rgba(250,250,248,0.90);
      border-radius: 12px;
      box-shadow: 0 3px 12px rgba(0,0,0,0.12);
    }
    .card {
      min-width: 160px;
      max-width: 220px;
      background: #fff;
      border-radius: 10px;
      box-shadow: 0 1px 6px rgba(0,0,0,0.12);
      padding: 10px 12px;
      cursor: pointer;
      transition: box-shadow 0.15s;
      display: flex;
      flex-direction: column;
      align-items: flex-start;
    }
    .card:hover {
      box-shadow: 0 2px 12px rgba(0,0,0,0.18);
      background: #f5f3ee;
    }
    .card-title {
      font-weight: bold;
      font-size: 13px;
      color: var(--accent);
      margin-bottom: 4px;
      line-height: 1.3;
      max-width: 100%;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }
    .card-thumb {
      width: 100%;
      height: 90px;
      object-fit: cover;
      border-radius: 7px;
      margin-bottom: 6px;
      background: #eae7df;
    }
    .card-tags {
      margin-top: 2px;
      display: flex;
      flex-wrap: wrap;
      gap: 3px;
    }
    .card-tag {
      background: #ece5d6;
      color: #5a5244;
      padding: 1px 5px;
      border-radius: 5px;
      font-size: 11px;
      line-height: 1.2;
    }
    @media (max-width: 640px) {
      #player { height: 38vw; max-height: 180px; }
      #cardStrip { width: 98vw; max-width: 99vw; }
      .card-thumb { height: 60px; }
      .card { min-width: 120px; max-width: 170px; padding: 7px 7px; }
      .card-title { font-size: 12px; }
    }
    </style>

  <link href="https://fonts.googleapis.com/css2?family=EB+Garamond&family=Noto+Serif+JP:wght@400;600&display=swap" rel="stylesheet" />

  <style>
    :root {
      --bg: #f3f1ed;        /* 落ち着いた生成り */
      --accent: #3f4a4b;    /* 深めのグレイッシュグリーン */
      --link: #385e6b;      /* くすみブルーグレー */
      --tip-h: 10px;  /* 三角高さ */
      --tip-gap: 2px; /* 三角とピンのクリアランス */
    }
  /* === Muted cluster palette === */
  .marker-cluster-small    { background: rgba(76,86,88,.15); }
  .marker-cluster-small div{ background:#4b5757; color:#f6f4ef; border:2px solid #f6f4ef; }
  .marker-cluster-medium   { background: rgba(67,78,80,.15); }
  .marker-cluster-medium div{ background:#435054; color:#f6f4ef; border:2px solid #f6f4ef; }
  .marker-cluster-large    { background: rgba(58,69,71,.15); }
  .marker-cluster-large div{ background:#3a4547; color:#f6f4ef; border:2px solid #f6f4ef; }
  .marker-cluster div{ box-shadow:0 1px 2px rgba(0,0,0,.15); font-weight:600; }
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      overflow: hidden;
      font-family: 'Noto Serif JP','EB Garamond',serif;
      background: var(--bg);
    }
    /* map は常に画面全面。古/新ビューポート単位と実測補正の三段構え */
    #map {
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      width: 100%;
      height: 100vh;     /* fallback */
      height: 100dvh;    /* modern */
      min-height: 100svh;/* iOS Safari */
    }

    /* iOS: prevent auto-zoom on focused form controls */
    input, textarea, select, button {
      font-size: 16px;
      -webkit-text-size-adjust: 100%;
    }

    /* iOS: respect safe areas and reduce bounce showing white gaps */
    body { padding-top: 0; }
    @media (max-width: 820px) { body { padding-top: env(safe-area-inset-top, 0px); } }
    html, body { overscroll-behavior: none; }

    .leaflet-container {
      background: #e9e4da;
      outline: none;
      width: 100% !important;
      height: 100% !important;
    }

    /* --- tile seam fixes (追加) --- */
    .leaflet-tile {
      background: none !important;
      border: none !important;
    }
    .leaflet-tile-container img { image-rendering: auto; }

    /* AWA風カード（角丸/影/サイズ） */
    .leaflet-container .leaflet-popup-content-wrapper {
      position: relative; /* カスタム三角の基準 */
      padding: 0;           /* メディアは端まで */
      border-radius: 16px;  /* 角を大きめに */
      box-shadow: 0 10px 24px rgba(0,0,0,0.20);
      background: #fff;
    }
    /* --- Popup tip: use centered down-pointing triangle (not diamond) --- */
    .leaflet-container .leaflet-popup-tip-container { display: none !important; }
    .leaflet-container .leaflet-popup-tip { display: none !important; }
    .leaflet-container .leaflet-popup-content-wrapper::after {
      content: "";
      position: absolute;
      left: 50%;
      transform: translateX(-50%);
      bottom: calc(-1 * var(--tip-h));
      width: 0; height: 0;
      border-left: var(--tip-h) solid transparent;
      border-right: var(--tip-h) solid transparent;
      border-top: var(--tip-h) solid #fff;  /* same color as card */
      filter: drop-shadow(0 2px 2px rgba(0,0,0,0.15));
      pointer-events: none;
    }

    /* 本体カードのタイポとサイズ感 */
    .popup-wrap {
      max-width: 360px; /* wider default */
      font-size: 13px;       /* 本文サイズ */
      line-height: 1.55;
    }
    .popup-img, .popup-video {
      width: 100%;
      display: block;
      border-radius: 16px 16px 0 0; /* 上だけ角丸、下は直線 */
      object-fit: cover;
    }
    /* 画像/動画のみ（テキストなし）の共通スタイル */
    .popup-wrap.media-only {
      max-width: 520px; /* 個別と同等の幅 */
      max-width: min(520px, 92vw); /* 画面に収まるよう上限をvwでも制御 */
      border-radius: 16px;     /* 画像/動画だけのとき → 上角丸、下角丸 */
      padding-bottom: 4px;     /* 下はわずかな余白のみ */
    }
    .popup-wrap.media-only .popup-img,
    .popup-wrap.media-only .popup-video {
      border-radius: 16px;     /* メディア単独時は上下とも角丸 */
    }
    
    /* 親のLeafletラッパーを画像/動画のみのときは上辺“角”にする（Chrome/Safariの :has 対応） */
    .leaflet-container .leaflet-popup-content-wrapper:has(.popup-wrap.media-only) {
      border-radius: 16px; /* 画像/動画だけのとき → 上下とも角丸 */
    }
    .leaflet-container .leaflet-popup-content-wrapper:has(.popup-wrap.media-only)::after {
      bottom: calc(-1 * var(--tip-h));
    }
    .popup-wrap img,
    .popup-wrap video {
      display: block;
      margin: 0;
      padding: 0;
    }
    .popup-iframe-wrap {
      width: 100%;
      aspect-ratio: 16 / 9; /* だいたい画像と近い比率 */
      background: #000;
      border-radius: 10px;
      overflow: visible;
      margin-bottom: 8px;
      box-shadow: 0 2px 6px rgba(0,0,0,0.2);
    }
    .popup-iframe-wrap iframe {
      width: 100%;
      height: 100%;
      border: 0;
      display: block;
    }

    /* --- swipeable media gallery --- */
    .media-gallery {
      display: flex;
      overflow-x: auto;
      gap: 8px;
      scroll-snap-type: x mandatory;
      -webkit-overflow-scrolling: touch;
      padding-bottom: 2px;
      margin-bottom: 8px;
    }
    .media-gallery::-webkit-scrollbar { display: none; }
    .media-slide { flex: 0 0 100%; scroll-snap-align: start; }
    .media-slide img,
    .media-slide video,
    .media-slide .popup-iframe-wrap { width: 100%; display: block; }
    .media-dots { display:flex; justify-content:center; gap:6px; margin-top:-4px; margin-bottom:6px; }
    .media-dot { width:6px; height:6px; border-radius:50%; background:#c9c2b2; }
    .media-dot.active { background:#7d7565; }
    .popup-title {
      font-weight: 700;
      font-size: 15px;
      color: var(--accent);
      margin: 8px 0 6px;
    }
    /* 本文エリアの内側余白 */
    .popup-body { padding: 10px 14px 12px; }
    /* メディアがあるときだけカード外枠のパディングをゼロに（上左右ぴったり） */
    .popup-wrap.has-media { padding: 0; }
    .popup-title a.title-link { color: var(--accent); text-decoration: none; }
    .popup-title a.title-link:hover { text-decoration: underline; }
    .tags {
      margin: 4px 0 6px;
      display: flex;
      flex-wrap: wrap;
      gap: 4px;
    }
    .tag {
      background: #ece5d6;
      color: #5a5244;
      padding: 2px 6px;
      border-radius: 6px;
      font-size: 11px;
      line-height: 1.2;
    }
    .popup-link {
      display:inline-block;
      margin-top:4px;
      color: var(--link);
      font-weight:600;
      text-decoration:none;
    }
    .popup-link:hover { text-decoration:underline; }

    .custom-marker-dot {
      width:12px; height:12px; /* 12 + 2px border*2 = 実寸16px（iconSizeと一致） */
      background: var(--accent);
      border-radius:50%;
      border:2px solid #fff;
      box-shadow:0 0 0 1px rgba(0,0,0,0.15);
    }
    .custom-current-location-dot {
      width:14px; height:14px;
      background: #7A1F1F; /* 渋めえんじ色 */
      border-radius:50%;
      border:2px solid #fff;
      box-shadow:0 0 0 1px rgba(0,0,0,0.15);
    }

    /* --- Aggregate marker with visible count --- */
    .agg-marker {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      background: var(--accent);
      color: #fff;
      border: 2px solid #fff;
      border-radius: 50%;
      font-weight: 700;
      box-shadow: 0 0 0 1px rgba(0,0,0,0.15);
      line-height: 1;
      user-select: none;
    }
    .agg-marker.small { width: 24px; height: 24px; font-size: 11px; }
    .agg-marker.mid   { width: 28px; height: 28px; font-size: 12px; }
    .agg-marker.large { width: 34px; height: 34px; font-size: 13px; }

    .legend {
      position: absolute;
      top: 60px;
      left: 10px;
      background: rgba(255,255,255,0.92);
      backdrop-filter: blur(4px);
      padding: 10px 12px;
      border-radius: 12px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.18);
      font-size: 12px;
      max-width: 240px;
    }
    .legend h1 {
      font-size: 15px;
      margin:0 0 6px;
      font-weight:600;
      color:#333;
    }
    .legend p {
      margin: 0 0 4px;
      color:#555;
      line-height:1.4;
    }
    .legend small { color:#777; font-size:11px; }

    /* 微細なサブピクセル隙間の抑制 */
    .leaflet-tile { outline: 1px solid transparent; }

    /* Leaflet popup: rounded rectangle, proper padding, normal tip arrow */
    .leaflet-container .leaflet-popup-content-wrapper {
      padding: 0; /* 角丸は上の基本設定(16px)を維持する */
    }
    .leaflet-container .leaflet-popup-content {
      margin: 0 !important;
    }

    /* --- force corners to be rounded when popup has only media --- */
    .leaflet-popup.shib-media-only .leaflet-popup-content-wrapper {
      border-radius: 16px !important; /* 画像/動画だけのとき → 上下とも角丸 */
      overflow: visible; /* ← 三角を切らない */
    }
    .leaflet-popup.shib-media-only .leaflet-popup-content {
      padding: 0 !important;
      margin: 0 !important;
    }
    .leaflet-popup.shib-media-only .popup-wrap,
    .leaflet-popup.shib-media-only .popup-media {
      border-radius: 16px !important;
    }
    .leaflet-popup.shib-media-only .popup-img,
    .leaflet-popup.shib-media-only .popup-video {
      border-radius: 16px !important; /* メディア単独時も上下とも角丸 */
    }
    .leaflet-container .leaflet-popup-tip {
      background: white;
    }


    @media (max-width: 640px) {
      .legend { font-size: 11px; }
      .popup-wrap { max-width: 240px; }
      .popup-img { height: 120px; }
      #jsonInput {
        max-height: 30vh;
        resize: vertical;
        overflow: auto;
        margin-bottom: 1em;
        width: 100%;
        box-sizing: border-box;
      }
      #inputPanel button {
        flex-shrink: 0;
        width: auto;
      }
    }

    #jsonInput {
      max-height: 30vh;
      resize: vertical;
      overflow: auto;
      margin-bottom: 1em;
      width: 100%;
      box-sizing: border-box;
      font-size: 16px;
      border: 1px solid #ccc;
      border-radius: 8px;
      background: #fff;
    }
    #jsonInput:focus {
      outline: none;
      border-color: #bbb; /* keep subtle, avoid system blue */
      box-shadow: none;
    }

    textarea {
      width: 100%;
      box-sizing: border-box;
    }

    /* --- inputPanel styles --- */
    #inputPanel {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      max-height: 50%;
      overflow-y: auto;
      background: #fff;
      padding: 10px;
      border-radius: 10px 10px 0 0;
      box-shadow: 0 -2px 6px rgba(0,0,0,0.2);
      z-index: 999;
      display: flex;
      flex-direction: column;
      will-change: transform;
      transition: transform 0.2s ease;
    }
    @supports (env(safe-area-inset-bottom)) {
      #inputPanel {
        padding-bottom: calc(10px + env(safe-area-inset-bottom));
      }
    }

    /* body.keyboard-open #inputPanel {
      transform: translateY(-300px); キーボード高さに応じて調整可能
    } */
    #inputPanel button {
      margin-top: 8px;
      margin-right: 8px;
    }
    #locStatus {
      margin-left: 6px;
      font-size: 12px;
      color: #555;
    }

    .button-row {
      display: flex;
      gap: 8px;
      overflow-x: auto;
      padding-top: 4px;
    }

    .icon-btn {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 32px;
      height: 32px;
      border: none;
      background: none;
      padding: 0;
      margin: 0;
      color: var(--accent);
      cursor: pointer;
    }
    .icon-btn svg { width: 18px; height: 18px; }
    .icon-btn:hover { color: #333; }

    #collapseBtn {
      /* now styled via .icon-btn */
    }
    #collapseBtn:hover {
      color: #333;
    }

    /* --- collapsible input panel & toggle button --- */
    #inputPanel.collapsed {
      transform: translateY(110%);
    }
    #inputPanel.collapsed { pointer-events: none; }
    #inputPanel.is-collapsed { transform: translateY(110%); pointer-events:none; }
    #panelToggleFab {
      position: fixed;
      right: 12px;
      bottom: 12px;
      z-index: 1000;
      background: #fff;
      border: 1px solid rgba(0,0,0,0.08);
      border-radius: 999px;
      width: 42px;
      height: 42px;
      box-shadow: 0 2px 6px rgba(0,0,0,0.2);
      display: none; /* shown via .show */
      padding: 0;
    }
    #panelToggleFab.show { display: inline-flex; align-items: center; justify-content: center; }
    @supports (env(safe-area-inset-bottom)) {
      #panelToggleFab { bottom: calc(12px + env(safe-area-inset-bottom)); }
    }

    /* === Class-based components (migration layer) === */
    :root {
      --btn-size-lg: 56px;
      --btn-font-lg: 14px;
      --safe-pad-b: calc(10px + env(safe-area-inset-bottom));
    }
    .toolbar { display:flex; gap:8px; align-items:center; }
    .toolbar.bottom {
      display: flex;
      flex-wrap: nowrap;            /* 一列保持（狭い画面はスクロール） */
      align-items: center;
      justify-content: flex-start;  /* 左寄せ（右端に押し出し用のautoが効く） */
      gap: 8px;
      padding: 4px 8px calc(6px + env(safe-area-inset-bottom)); /* 上下の余白を減らす */
      overflow-x: auto;             /* 狭い画面で横スクロール */
    }
    .btn {
      display:inline-flex;
      align-items:center;
      justify-content:center;
      gap:6px;
      border-radius:12px;
      border:1px solid rgba(0,0,0,0.08);
      background:#fff;
      color:var(--accent);
      padding: 8px 16px; /* 上下の余白を減らしてコンパクト化 */
      font-size:var(--btn-font-lg);
      line-height:1;
      cursor:pointer;
    }
    .btn:hover { background:#f6f4ef; }
    .btn--icon { width:var(--btn-size-lg); height:var(--btn-size-lg); padding:0; border-radius:999px; }
    .btn--fab { width:var(--btn-size-lg); height:var(--btn-size-lg); border-radius:999px; box-shadow:0 2px 6px rgba(0,0,0,0.2); }


    /* Collapsed state (class-based modifier) */
    .is-collapsed { transform: translateY(110%); pointer-events:none; }

    @media (max-width: 430px) {
      .toolbar.bottom { padding-bottom: var(--safe-pad-b); }
      /* If any min-width/min-height for .btn is present in mobile, remove/comment it out */
      /* .btn { min-width: unset !important; min-height: unset !important; } */
    }

    #weekPanel.is-collapsed { transform: translateY(110%); pointer-events:none; }
  </style>
  <script>
    // iOS Safariキーボード表示による画面の余白対策
    function setRealVh() {
      let vh = window.innerHeight * 0.01;
      document.documentElement.style.setProperty('--vh', `${vh}px`);
      const mapEl = document.getElementById('map');
      if (mapEl) {
        const h = Math.max(window.innerHeight, (document.documentElement && document.documentElement.clientHeight) || 0);
        mapEl.style.height = h + 'px';
        mapEl.style.minHeight = h + 'px';
      }
      if (typeof map !== 'undefined') {
        setTimeout(() => map.invalidateSize(true), 100); // ← 強制再描画
      }
    }
    window.addEventListener('resize', setRealVh);
    window.addEventListener('orientationchange', setRealVh);
    setRealVh();
    window.addEventListener('load', setRealVh);
// --- Japan strict geofence (排他的矩形) ---
function isJapanStrict(lat, lng){
  // 北海道
  if (lat>=41.2 && lat<=45.7 && lng>=139.0 && lng<=146.5) return true;
  // 本州（おおまかに、韓国側を避けるため西端を 129.8 より東）
  if (lat>=33.0 && lat<=41.6 && lng>=129.8 && lng<=142.3) return true;
  // 四国
  if (lat>=32.5 && lat<=34.8 && lng>=132.0 && lng<=134.9) return true;
  // 九州（緯度は34未満に制限 → 釜山(≈35,129)を除外）
  if (lat>=30.0 && lat<34.0 && lng>=129.0 && lng<=132.0) return true;
  // 沖縄
  if (lat>=24.0 && lat<=27.0 && lng>=122.0 && lng<=130.0) return true;
  return false;
}
// 韓国の排他的矩形（釜山混入を確実に防ぐ）
function isKoreaStrict(lat, lng){
  // 朝鮮半島の概形（済州含む広めの矩形だが、対馬・九州は含めない）
  // lat: 33–39, lng: 124.5–131
  return (lat>=33.0 && lat<=39.0 && lng>=124.5 && lng<=131.0);
}

    // Collapsible input panel controls
    function setPanelCollapsed(collapsed) {
      const panel = document.getElementById('inputPanel');
      const fab = document.getElementById('panelToggleFab');
      if (!panel || !fab) return;
      if (collapsed) {
        panel.classList.add('collapsed');
        panel.classList.add('is-collapsed');
        fab.classList.add('show');
        fab.setAttribute('aria-expanded', 'false');
        localStorage.setItem('ShibmapPanelCollapsed', '1');
      } else {
        panel.classList.remove('collapsed');
        panel.classList.remove('is-collapsed');
        fab.classList.remove('show');
        fab.setAttribute('aria-expanded', 'true');
        localStorage.setItem('ShibmapPanelCollapsed', '0');
      }
    }
    function togglePanel(collapse) {
      setPanelCollapsed(Boolean(collapse));
      // フォーカスの誘導（開いたとき）
      if (!collapse) {
        setTimeout(() => document.getElementById('jsonInput')?.focus(), 80);
      }
      // パネル開閉後に地図サイズを再計算（CSS transition 0.2sに合わせる）
      setTimeout(() => { if (typeof map !== 'undefined') map.invalidateSize(true); }, 220);
    }
  </script>
</head>
<body>
  <div id="map"></div>
  <!-- 動画プレイヤー -->
  <div id="player">
    <video id="vid" controls playsinline webkit-playsinline style="width:100%;height:100%;border-radius:16px;background:#111;"></video>
  </div>
  <!-- カードスライドUI -->
  <div id="cardStrip" style="display:none;"></div>
  <div id="inputPanel">
      <textarea id="jsonInput" rows="6" placeholder="ここにJSONデータを貼り付け"></textarea>
      <div class="button-row toolbar bottom">
        <button id="clearButton" class="btn" onclick="clearMarkers()">地図をクリア</button>
        <button id="loadButton" class="btn" onclick="loadCustomMarkers()">地図に表示</button>
        <button id="locateBtn" class="btn" onclick="locateNow(true)">現在地</button>
        <label style="margin-left:auto;display:flex;align-items:center;gap:6px;font-size:12px;color:#555">
          集約単位
          <select id="aggregateMode" onchange="loadCustomMarkers()" style="font-size:12px;border:1px solid #ccc;border-radius:6px;padding:2px 6px;background:#fff">
            <option value="pref">県ごと</option>
            <option value="region">広域（地方）</option>
            <option value="none" selected>集約なし（個別表示）</option>
          </select>
        </label>
        <button id="collapseBtn" class="btn" onclick="togglePanel(true)" title="入力パネルを隠す">↓</button>
      </div>
      <span id="locStatus"></span>
    </div>
<button id="panelToggleFab" class="btn btn--fab" onclick="togglePanel(false)" aria-label="入力を開く" title="入力を開く">
  <svg viewBox="0 0 24 24" aria-hidden="true"><path fill="currentColor" d="M7.41 15.41 12 10.83l4.59 4.58L18 14l-6-6-6 6z"/></svg>
</button>

  <script>
  /*
  例:
  [
    {
      "title": "彩虹邨（Choi Hung Estate）",
      "coords": [22.333189, 114.211905],
      "tags": ["香港", "バスケ"],
      "note": "香港で見つけたawaバスケットコート",
      "image": "images/choihung.jpg",
      "link": "https://example.com"
    }
  ]
  */
    // 追加：現在のマーカーを記録
    let currentMarkers = [];
    let currentLocationMarker = null;
    // ---- 基本マップ ----
    // Popup geometry (must match CSS :root)
    const TIP_H = 10;  // px, --tip-h
    const TIP_GAP = 2; // px, --tip-gap
    const map = L.map('map', {
      dragging: true,
      tap: false,
      minZoom: 0,
      maxZoom: 18,
      worldCopyJump: true,       // 横方向の連続パンを滑らかに
      zoomSnap: 1,               // 小数ズームをやめて白線/カクつきを抑制
      zoomDelta: 1,
      wheelDebounceTime: 25,
      wheelPxPerZoomLevel: 160,   // ← 元の滑らかさに戻す
      zoomAnimation: true,        // ← アニメーション復活
      zoomAnimationThreshold: 4,  // ← Leafletのデフォルト近辺
      fadeAnimation: true         // ← タイルのフェードも復活
    });

    if (map.dragging && !map.dragging.enabled()) { map.dragging.enable(); }

    if (window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
      map.options.zoomAnimation = false;
      map.options.fadeAnimation = false;
    }
// --- aggregation helpers ---
const REGION_BBOX = [
  { key:'北海道',  west:139.0, east:146.5, south:41.2, north:45.7 },
  { key:'東北',    west:139.0, east:142.3, south:37.0, north:41.6 },
  { key:'関東',    west:138.7, east:141.1, south:34.8, north:37.1 },
  { key:'中部',    west:136.0, east:138.8, south:35.0, north:37.7 },
  { key:'近畿',    west:134.1, east:136.7, south:33.8, north:35.9 },
  { key:'中国',    west:130.8, east:134.2, south:33.5, north:35.6 },
  { key:'四国',    west:132.0, east:134.9, south:32.5, north:34.8 },
  { key:'九州・沖縄', west:122.9, east:131.0, south:24.0, north:33.8 }
];
const PREF_CENTROIDS = [
  { name:'北海道', lat:43.06417, lng:141.34694 },
  { name:'青森県', lat:40.82444, lng:140.74 },
  { name:'岩手県', lat:39.70361, lng:141.1525 },
  { name:'宮城県', lat:38.26889, lng:140.87194 },
  { name:'秋田県', lat:39.71861, lng:140.1025 },
  { name:'山形県', lat:38.24056, lng:140.36333 },
  { name:'福島県', lat:37.75, lng:140.46778 },
  { name:'茨城県', lat:36.34139, lng:140.44667 },
  { name:'栃木県', lat:36.56583, lng:139.88361 },
  { name:'群馬県', lat:36.39111, lng:139.06083 },
  { name:'埼玉県', lat:35.85694, lng:139.64889 },
  { name:'千葉県', lat:35.60472, lng:140.12333 },
  { name:'東京都', lat:35.68944, lng:139.69167 },
  { name:'神奈川県', lat:35.44778, lng:139.6425 },
  { name:'新潟県', lat:37.90222, lng:139.02361 },
  { name:'富山県', lat:36.69528, lng:137.21139 },
  { name:'石川県', lat:36.59444, lng:136.62556 },
  { name:'福井県', lat:36.06528, lng:136.22194 },
  { name:'山梨県', lat:35.66389, lng:138.56833 },
  { name:'長野県', lat:36.65139, lng:138.18111 },
  { name:'岐阜県', lat:35.39111, lng:136.72222 },
  { name:'静岡県', lat:34.97556, lng:138.3825 },
  { name:'愛知県', lat:35.18028, lng:136.90667 },
  { name:'三重県', lat:34.73028, lng:136.50861 },
  { name:'滋賀県', lat:35.00444, lng:135.86833 },
  { name:'京都府', lat:35.01167, lng:135.76833 },
  { name:'大阪府', lat:34.68639, lng:135.52 },
  { name:'兵庫県', lat:34.69139, lng:135.18306 },
  { name:'奈良県', lat:34.68528, lng:135.83278 },
  { name:'和歌山県', lat:34.22611, lng:135.1675 },
  { name:'鳥取県', lat:35.50361, lng:134.23833 },
  { name:'島根県', lat:35.47222, lng:133.05056 },
  { name:'岡山県', lat:34.66167, lng:133.935 },
  { name:'広島県', lat:34.39639, lng:132.45944 },
  { name:'山口県', lat:34.18583, lng:131.47139 },
  { name:'徳島県', lat:34.06583, lng:134.55944 },
  { name:'香川県', lat:34.34028, lng:134.04333 },
  { name:'愛媛県', lat:33.84167, lng:132.76611 },
  { name:'高知県', lat:33.55972, lng:133.53111 },
  { name:'福岡県', lat:33.60639, lng:130.41806 },
  { name:'佐賀県', lat:33.24944, lng:130.29889 },
  { name:'長崎県', lat:32.74472, lng:129.87361 },
  { name:'熊本県', lat:32.78972, lng:130.74167 },
  { name:'大分県', lat:33.23806, lng:131.6125 },
  { name:'宮崎県', lat:31.91111, lng:131.42389 },
  { name:'鹿児島県', lat:31.56028, lng:130.55806 },
  { name:'沖縄県', lat:26.2125, lng:127.68111 }
];
function jpNearestPref(lat, lng) {
  if (!isJapanStrict(lat, lng)) return { pref:'', city:'' };
  let best = null, bestD2 = Infinity;
  for (const p of PREF_CENTROIDS) {
    const dx = (lng - p.lng), dy = (lat - p.lat);
    const d2 = dx*dx + dy*dy; // rough planar; sufficient at JP scale
    if (d2 < bestD2) { bestD2 = d2; best = p; }
  }
  // sanity: if extremely far (shouldn’t happen within JP bbox), fall back to empty
  if (!best) return { pref:'', city:'' };
  return { pref: best.name, city: '' };
}
// 日本の都道府県→広域地域マップ（一般的な区分に準拠）
const PREF_TO_REGION = {
  '北海道':'北海道',
  '青森県':'東北','岩手県':'東北','宮城県':'東北','秋田県':'東北','山形県':'東北','福島県':'東北',
  '茨城県':'関東','栃木県':'関東','群馬県':'関東','埼玉県':'関東','千葉県':'関東','東京都':'関東','神奈川県':'関東',
  '新潟県':'中部','富山県':'中部','石川県':'中部','福井県':'中部','山梨県':'中部','長野県':'中部','岐阜県':'中部','静岡県':'中部','愛知県':'中部',
  '三重県':'近畿','滋賀県':'近畿','京都府':'近畿','大阪府':'近畿','兵庫県':'近畿','奈良県':'近畿','和歌山県':'近畿',
  '鳥取県':'中国','島根県':'中国','岡山県':'中国','広島県':'中国','山口県':'中国',
  '徳島県':'四国','香川県':'四国','愛媛県':'四国','高知県':'四国',
  '福岡県':'九州・沖縄','佐賀県':'九州・沖縄','長崎県':'九州・沖縄','熊本県':'九州・沖縄','大分県':'九州・沖縄','宮崎県':'九州・沖縄','鹿児島県':'九州・沖縄','沖縄県':'九州・沖縄'
};

function getRegionByLatLng(lat, lng){
  // 日本域内は県の最近傍で地域を決める（県境の閾値問題を回避）
  if (isJapanStrict(lat, lng)) {
    const { pref } = jpNearestPref(lat, lng) || {};
    const region = PREF_TO_REGION[pref] || '中部'; // 静岡など境界を確実に中部へ
    return region;
  }
  // 韓国は単一地域として扱う（日本と混在しないように）
  if (isKoreaStrict(lat, lng)) return '韓国';

  // 海外（JP/KR以外）は“その他”で潰さず、粗いグリッドで地域キーを分離
  const step = 2.0; // 度（約200〜220km）
  const glat = (Math.round(lat / step) * step).toFixed(1);
  const glng = (Math.round(lng / step) * step).toFixed(1);
  return `GRID@${glat},${glng}`;
}
function reverseGeocodePrefCity(lat, lng) {
  // Prefer offline nearest-centroid mapping for Japan; return empty for others
  const inJP = isJapanStrict(lat, lng);
  if (inJP) return jpNearestPref(lat, lng);
  return { pref: '', city: '' };
}
function getAggregateKeyFor(item){
  const modeEl = document.getElementById('aggregateMode');
  const mode = modeEl ? modeEl.value : 'region';
  const lat = item?.coords?.[0], lng = item?.coords?.[1];

  if (typeof lat !== 'number' || typeof lng !== 'number') return 'invalid';

  // 明示的な国識別（日本/韓国）で海越え結合を防止
  const inJP = isJapanStrict(lat, lng);
  const inKR = !inJP && isKoreaStrict(lat, lng);
  const country = inJP ? 'JP' : (inKR ? 'KR' : 'WW');

  if (mode === 'pref') {
    // 1) データに pref/city があれば最優先（将来の逆ジオ結果を尊重）
    if (item && typeof item.pref === 'string' && item.pref) return `${country}:${item.pref}`;
    if (item && typeof item.city === 'string' && item.city) return `${country}:${item.city}`;

    // 2) 簡易逆ジオ
    const geo = reverseGeocodePrefCity(lat, lng);
    if (geo && typeof geo.pref === 'string' && geo.pref) return `${country}:${geo.pref}`;
    if (geo && typeof geo.city === 'string' && geo.city) return `${country}:${geo.city}`;

    // 3) フォールバック: 国ごとに独立したグリッドキー
    //    日本は県粒度に近づけるため細かめ、国外はやや粗め
    const step = inJP ? 0.25 : 0.60; // (度)
    const glat = (Math.round(lat / step) * step).toFixed(3);
    const glng = (Math.round(lng / step) * step).toFixed(3);
    return `${country}@${glat},${glng}`;
  }

  // 地域モード: ここは従来通り。ただし国識別を接頭辞として付与しておく
  return `${country}:${getRegionByLatLng(lat, lng)}`;
}
// グループ化：keyごとに items をまとめ、中心を平均で取る
function buildAggregateGroups(items) {
  const groups = new Map();
  for (const it of items) {
    if (!it.coords || !Array.isArray(it.coords) || it.coords.length !== 2) continue;
    const key = getAggregateKeyFor(it); // ここで「日本→pref、国外→city/region」などのキー化
    if (!groups.has(key)) groups.set(key, { key, items: [], sumLat: 0, sumLng: 0 });
    const g = groups.get(key);
    g.items.push(it);
    g.sumLat += it.coords[0];
    g.sumLng += it.coords[1];
  }
  return Array.from(groups.values()).map(g => ({
    key: g.key,
    items: g.items,
    center: [g.sumLat / g.items.length, g.sumLng / g.items.length]
  }));
}

// 媒体（画像/動画）のみで構成したグリッド（最大12）
function buildAggregatePopupHTML(groupItems) {
  if (!Array.isArray(groupItems) || groupItems.length === 0) return '';
  const medias = [];
  for (const it of groupItems) {
    if (Array.isArray(it.gallery) && it.gallery.length) {
      for (const u of it.gallery) medias.push({ url: u, poster: it.image || '' });
    } else if (it.video) {
      medias.push({ url: it.video, poster: it.image || '' });
    } else if (it.image) {
      medias.push({ url: it.image, poster: '' });
    }
    if (medias.length >= 24) break;
  }
  if (medias.length === 0) {
    const list = groupItems.map(it => `<li>${escapeHTML(it.title||'')}</li>`).join('');
    return `<div class="popup-wrap"><div class="popup-body"><ul style="margin:6px 0 6px 18px; padding:0">${list}</ul></div></div>`;
  }
  const tiles = medias.slice(0, 12).map(m => {
    const u = m.url || '';
    if (!u) return '';
    if (/\.(mp4|m4v|webm|ogv|ogg|mov)(\?.*)?$/i.test(u)) {
      const src = encodeURI(u);
      return `<video class="popup-video" src="${escapeHTML(src)}" autoplay muted loop playsinline webkit-playsinline preload="metadata" onerror="videoFallback(this)" style="width:100%;border-radius:8px"></video>`;
    }
    if (/\.(apng|avif|gif|jpe?g|png|webp)(\?.*)?$/i.test(u)) {
      const src = encodeURI(u);
      return `<img class="popup-img" src="${escapeHTML(src)}" alt="" style="width:100%;border-radius:8px" onerror="this.onerror=null;this.src='${FALLBACK_IMG}'">`;
    }
    return '';
  }).filter(Boolean).map(h => `<div class="media-grid-item">${h}</div>`).join('');
  return `
  <style>
    .media-grid { display:grid; grid-template-columns:repeat(3,1fr); gap:6px; padding:6px; border-radius:12px; overflow:hidden; }
    @media (max-width:480px){ .media-grid{ grid-template-columns:repeat(2,1fr); } }
    .media-grid-item video,.media-grid-item img{ display:block; width:100%; height:auto; border-radius:8px; }
    .media-grid:has(.media-grid-item:nth-child(1)) { grid-template-columns:repeat(1,1fr); }
    .media-grid:has(.media-grid-item:nth-child(2)) { grid-template-columns:repeat(2,1fr); }
  </style>
  <div class="popup-wrap media-only"><div class="media-grid">${tiles}</div></div>`;
}

    // 初期表示は日本（東京中心、ズーム5）にフォーカス
    map.setView([35.68, 139.76], 5);
    // --- clamp latitude only (keep horizontal wrap) ---
    const LAT_MIN = -85.05112878, LAT_MAX = 85.05112878; // Web Mercator 実上限
    let isClamping = false;
    function clampLatImmediate() {
      if (!map || !map._loaded) return; // map が ready になるまで何もしない
      const c = map.getCenter();
      let lat = c.lat;
      if (lat > LAT_MAX) lat = LAT_MAX;
      else if (lat < LAT_MIN) lat = LAT_MIN;
      if (!isClamping && Math.abs(lat - c.lat) > 1e-6) {
        isClamping = true;
        map.panTo([lat, c.lng], { animate: false });
        isClamping = false;
      }
    }
    // パン中も連続的に補正して“自然に”止める（横はラップ維持）
    map.on('move', clampLatImmediate);
    map.on('zoomend', clampLatImmediate);
    map.on('load', clampLatImmediate);
    map.on('resize', clampLatImmediate);
    // Note: Web Mercator(EPSG:3857) は垂直方向の“無限ラップ”をサポートしないため、南北端では薄い余白が生じます。
    requestAnimationFrame(() => map.invalidateSize(true));

    // ---- 現在地表示 ----
    function locateNow(fromUser = false) {
      const status = document.getElementById('locStatus');
      if (status) status.textContent = '現在地取得中…';

      const isSecure = (location.protocol === 'https:' || location.hostname === 'localhost' || location.hostname === '127.0.0.1');
      if (!isSecure) {
        console.warn('現在地は https または localhost でのみ取得できます。');
        if (fromUser && status) status.textContent = 'https または localhost で利用してください';
        return;
      }

      if (!navigator.geolocation) {
        console.warn('このブラウザはGeolocationに対応していません。');
        if (fromUser && status) status.textContent = 'Geolocationに非対応のブラウザです';
        return;
      }

      const applyPos = (p) => {
        const latlng = [p.coords.latitude, p.coords.longitude];
        if (currentLocationMarker) {
          currentLocationMarker.setLatLng(latlng);
        } else {
          const currentIcon = L.divIcon({
            className: '',
            html: '<div class="custom-current-location-dot"></div>',
            iconSize: [16,16],
            iconAnchor: [8,8],
            popupAnchor: [0,-4]
          });
          currentLocationMarker = L.marker(latlng, { icon: currentIcon })
            .addTo(map)
            .bindPopup('あなたの現在地');
        }
        if (fromUser) map.setView(latlng, Math.max(map.getZoom(), 14));
        if (status) status.textContent = '';
      };

      const onErr = (err) => {
        console.warn('現在地の取得に失敗:', err.message);
        if (fromUser && status) {
          if (err.code === err.PERMISSION_DENIED) status.textContent = '位置情報がブロックされています。サイトの設定から許可してください。';
          else if (err.code === err.TIMEOUT) status.textContent = '取得がタイムアウトしました。屋外で再試行を。';
          else status.textContent = '現在地取得に失敗: ' + err.message;
        }
      };

      // ① 速い（キャッシュ優先）
      navigator.geolocation.getCurrentPosition(applyPos, onErr, {
        enableHighAccuracy: false,
        timeout: 1000,
        maximumAge: 300000 // 5分以内なら即返す
      });

      // ② 高精度で上書き
      navigator.geolocation.getCurrentPosition(applyPos, onErr, {
        enableHighAccuracy: true,
        timeout: 15000,
        maximumAge: 0
      });
    }

    // country-separated cluster groups (to avoid cross-country merging like JP+KR)
    let clusterGroupMap = new Map();
    let clusterLayerGroup = L.layerGroup();
    map.whenReady(() => {
      locateNow(false);

      L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png', {
        attribution: '&copy; OpenStreetMap contributors &copy; CartoDB',
        noWrap: false,
        updateWhenDragging: true,
        updateWhenZooming: true,
        keepBuffer: 2,
        detectRetina: false
      }).addTo(map);

      map.addLayer(clusterLayerGroup);

      // Build a cluster group (shared options); set radius depending on mode
      function buildClusterGroup() {
        const group = L.markerClusterGroup({
          showCoverageOnHover: false,
          spiderfyOnMaxZoom: false,
          zoomToBoundsOnClick: false,
          disableClusteringAtZoom: 11,
          maxClusterRadius: function (zoom) {
            const modeEl = document.getElementById('aggregateMode');
            const mode = modeEl ? modeEl.value : 'region';
            if (mode === 'pref') return 20; // allow modest clustering in pref mode
            if (zoom <= 3) return 10;
            if (zoom <= 5) return 18;
            return 28;
          }
        });
        // cluster click: show media-only popup of merged items (within same country)
        group.on('clusterclick', function (e) {
          const markers = e.layer.getAllChildMarkers();
          const items = markers
            .flatMap(m => (m.options.__rawItems ? m.options.__rawItems : (m.options.__rawItem ? [m.options.__rawItem] : [])))
            .filter(Boolean);
          const html = buildAggregatePopupHTML(items);
          if (!html) return;
          L.popup({ maxWidth: 600, minWidth: 260, autoPanPaddingTopLeft: [24, 24], autoPanPaddingBottomRight: [24, 24], offset: L.point(0, 4), className: 'shib-media-only' })
            .setLatLng(e.latlng)
            .setContent(html)
            .openOn(map);
        });
        return group;
      }

      // Get country prefix from aggregate key (e.g., "JP:北海道", "KR@37.5,127.0", "WW:その他")
      function getCountryFromKey(key) {
        if (!key || typeof key !== 'string') return 'WW';
        const p = key.split(':')[0];
        return p ? p : 'WW';
      }

      function getCountryCluster(key) {
        const c = getCountryFromKey(key);
        if (clusterGroupMap.has(c)) return clusterGroupMap.get(c);
        const grp = buildClusterGroup();
        clusterGroupMap.set(c, grp);
        clusterLayerGroup.addLayer(grp);
        return grp;
      }

      // === 初期データのロードは map/cluster 初期化後に行う ===
      const savedAtReady = localStorage.getItem('ShibmapData');
      if (savedAtReady) {
        document.getElementById('jsonInput').value = savedAtReady;
        const __callLoadSafely = () => {
          if (typeof window.loadCustomMarkers === 'function') {
            try { window.loadCustomMarkers(); } catch (e) { console.error('load at ready failed:', e); }
          } else {
            // 次フレームで再試行（後続の <script> で関数が定義されるまで待つ）
            setTimeout(__callLoadSafely, 0);
          }
        };
        __callLoadSafely();
      }
      // Expose helpers for use in loadCustomMarkers
      window.getCountryCluster = getCountryCluster;
      window.clusterGroupMap = clusterGroupMap;
      window.clusterLayerGroup = clusterLayerGroup;
    });

    // ---- カスタムアイコン ----
    function createIcon() {
      return L.divIcon({
        className: '',
        html: '<div class="custom-marker-dot"></div>',
        iconSize: [16,16],
        iconAnchor: [8,8],
        popupAnchor: [0, 0]
      });
    }

    // Aggregate marker icon with visible count
    function createAggIcon(count) {
      const cls = (count >= 100) ? 'large' : (count >= 10 ? 'mid' : 'small');
      const size = (cls === 'large') ? 34 : (cls === 'mid' ? 28 : 24);
      return L.divIcon({
        className: '',
        html: `<div class="agg-marker ${cls}">${count}</div>`,
        iconSize: [size, size],
        iconAnchor: [size/2, size/2],
        popupAnchor: [0, 0]
      });
    }

    // ---- HTMLエスケープ ----
    function escapeHTML(str='') {
      return str.replace(/[&<>"']/g, s => ({
        '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'
      }[s]));
    }

    const FALLBACK_IMG = 'images/placeholder.jpg'; // 必要なら配置

    // 動画が再生できない（コーデック/アクセス権など）場合のフォールバック
    function videoFallback(videoEl){
      try{
        var parent = videoEl && videoEl.parentNode;
        if (!parent) return; // 親が無ければ何もしない

        var src = videoEl.currentSrc || videoEl.getAttribute('src') || '';
        var poster = videoEl.getAttribute('poster') || '';

        // まずポスター/推測画像を準備
        var img = new Image();
        img.className = 'popup-img';
        img.onload = function(){
          img.style.aspectRatio = img.naturalWidth + '/' + img.naturalHeight;
        };
        img.onerror = function(){
          // 画像もダメならリンクだけを表示
          var a = document.createElement('a');
          a.href = src; a.target = '_blank'; a.rel = 'noopener';
          a.className = 'popup-link'; a.textContent = 'メディアを開く';
          if (parent.contains(videoEl)) {
            try { parent.replaceChild(a, videoEl); } catch(_) { parent.appendChild(a); }
          } else {
            parent.appendChild(a);
          }
        };

        var guessImg = poster || src.replace(/\.[a-z0-9]+(\?.*)?$/i, '.jpg');
        img.src = guessImg;

        // 置換は必ず存在確認してから行う（Leafletの再レンダリング対策）
        if (parent.contains(videoEl)) {
          try { parent.replaceChild(img, videoEl); } catch(_) { parent.appendChild(img); }
        } else {
          parent.appendChild(img);
        }
      }catch(e){ console.error('videoFallback error:', e); }
    }

    // 画像/動画/ギャラリー対応（YouTube/Vimeo/直リンク動画）。
    // ・ギャラリー: item.gallery = [url, url, ...]
    // ・単体: item.video or item.image
    // すべて "自動ミュート再生・playsinline" を優先（ユーザー操作なしで再生可能な範囲）
    function buildMediaHTML(item = {}) {
      const escape = (s='') => escapeHTML(s);
      const fallbackImg = FALLBACK_IMG;

      // URL → メディア要素HTML（単体）
      function buildSingleMedia(url, poster='') {
        const raw = (url || '').toString().trim();
        const rawPoster = (poster || '').toString().trim();
        if (!raw) return '';

        // ---- 正規化：ロジックは “生のURL文字列” で行い、最後に HTML エスケープ ----
        function normalizeURL(u) {
          // ローカル絶対パスは file:/// を付与
          if (location.protocol === 'file:' && /^\/Users\//.test(u)) {
            u = 'file://' + u;
          }
          // 日本語/スペースなどを URL エンコード（スキームや ://, ?, &, = は保持）
          return encodeURI(u);
        }

        const srcFixed = normalizeURL(raw);
        const posterFixed = rawPoster ? normalizeURL(rawPoster) : '';
        const srcAttr = escapeHTML(srcFixed);
        const posterAttr = posterFixed ? ` poster="${escapeHTML(posterFixed)}"` : '';

        // YouTube
        {
          const yt = srcFixed.match(/(?:youtu\.be\/|youtube(?:-nocookie)?\.com\/(?:watch\?v=|embed\/))([A-Za-z0-9_-]{11})/);
          if (yt) {
            const id = yt[1];
            const src = `https://www.youtube-nocookie.com/embed/${id}?rel=0&modestbranding=1&playsinline=1&autoplay=1&mute=1&controls=1`;
            return `<div class="popup-iframe-wrap"><iframe src="${escapeHTML(src)}" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen loading="lazy"></iframe></div>`;
          }
        }

        // Vimeo
        {
          const vm = srcFixed.match(/vimeo\.com\/(?:video\/)?(\d+)/);
          if (vm) {
            const id = vm[1];
            const src = `https://player.vimeo.com/video/${id}?autoplay=1&muted=1&playsinline=1`;
            return `<div class="popup-iframe-wrap"><iframe src="${escapeHTML(src)}" allow="autoplay; fullscreen; picture-in-picture" allowfullscreen loading="lazy"></iframe></div>`;
          }
        }

        // 直接動画（mp4/m4v/webm/ogv/ogg/mov）
        if (/\.(mp4|m4v|webm|ogv|ogg|mov)(\?.*)?$/i.test(srcFixed)) {
          const ext = srcFixed.split('.').pop().toLowerCase().split('?')[0];
          const mimeMap = { mp4:'video/mp4', m4v:'video/mp4', webm:'video/webm', ogv:'video/ogg', ogg:'video/ogg', mov:'video/quicktime' };
          const mime = mimeMap[ext] || 'video/mp4';
          return `<video class="popup-video" src="${srcAttr}" autoplay muted loop playsinline webkit-playsinline controls preload="metadata"${posterAttr}
            onloadedmetadata="this.style.aspectRatio=(this.videoWidth + '/' + this.videoHeight)"
            onerror="videoFallback(this)">
            <source src="${srcAttr}" type="${mime}">
          </video>`;
        }

        // 画像
        if (/\.(apng|avif|gif|jpe?g|png|webp)(\?.*)?$/i.test(srcFixed)) {
          return `<img src="${srcAttr}" alt="" class="popup-img" onload="this.style.aspectRatio=(this.naturalWidth + '/' + this.naturalHeight)" onerror="this.onerror=null;this.src='${fallbackImg}'; this.classList.add('fallback-img');">`;
        }

        // 未判定 → リンク（※ダウンロード誘導はしない）
        return `<a class="popup-link" href="${srcAttr}" target="_blank" rel="noopener">メディアを開く</a>`;
      }

      // ギャラリー優先
      const gallery = Array.isArray(item.gallery) ? item.gallery : null;
      const poster = item.image || '';
      if (gallery && gallery.length) {
        const slides = gallery.map((u, i) => `<div class="media-slide">${buildSingleMedia(u, poster)}</div>`).join('');
        // シンプルなスクロールスナップ + ドット
        const dots = gallery.map((_, i) => `<span class="media-dot${i===0?' active':''}"></span>`).join('');
        // ドットのアクティブ更新（スクロール位置に応じて）
        const id = `gal_${Math.random().toString(36).slice(2)}`;
        const script = `<script>(function(){
          const wrap=document.getElementById('${id}');
          if(!wrap) return; const dots=[...wrap.querySelectorAll('.media-dot')];
          wrap.querySelector('.media-gallery').addEventListener('scroll',function(e){
            const el=e.currentTarget; const idx=Math.round(el.scrollLeft/el.clientWidth);
            dots.forEach((d,i)=>d.classList.toggle('active', i===idx));
          },{passive:true});
        })();<\/script>`;
        return `<div id="${id}"><div class="media-gallery">${slides}</div><div class="media-dots">${dots}</div></div>${script}`;
      }

      // 単体（video優先）
      const video = item.video || '';
      if (video) return buildSingleMedia(video, poster);
      const img = item.image || '';
      if (img) return buildSingleMedia(img);
      return `<img src="${fallbackImg}" alt="" class="popup-img">`;
    }

  </script>
  <script>


// 寛容パーサ：末尾カンマ/コメント/BOMを除去してから JSON.parse
function parseLooseJson(input) {
  if (typeof input !== 'string') return input;
  let s = input.trim();
  // BOM除去
  if (s.charCodeAt(0) === 0xFEFF) s = s.slice(1);
  // コメント削除 (// ... と /* ... */)
  s = s.replace(/(^|\n)\s*\/\/.*(?=\n|$)/g, '$1');
  s = s.replace(/\/\*[\s\S]*?\*\//g, '');
  // 末尾カンマ削除: オブジェクト/配列の直前にある余分なカンマを除去
  s = s.replace(/,\s*(\}|\])/g, '$1');
  // 全角カンマ→半角（うっかり対策）
  s = s.replace(/，/g, ',');
  return JSON.parse(s);
}

// 関数外にこれを追加（表示済みマーカーの記録用）
const addedMarkerSet = new Set();

    function loadCustomMarkers() {
      console.log("Loading custom markers...");
      // マップが未初期化なら次フレームにリトライ
      if (!map || !map._loaded) {
        console.warn('loadCustomMarkers: map not ready, retrying...');
        setTimeout(loadCustomMarkers, 0);
        return;
      }
      const input = document.getElementById('jsonInput').value;
      try {
        const items = parseLooseJson(input);
        console.log(items);
        localStorage.setItem('ShibmapData', input);

        // 既存マーカー削除
        currentMarkers.forEach(marker => map.removeLayer(marker));
        currentMarkers = [];
        addedMarkerSet.clear();
        // remove all existing per-country cluster groups from map/layer group
        clusterLayerGroup.clearLayers();
        clusterGroupMap.forEach(g => { try { g.clearLayers(); } catch (_) {} });
        clusterGroupMap = new Map();

        // 集約モード取得（none=個別表示）
        const modeEl = document.getElementById('aggregateMode');
        const uiMode = modeEl ? modeEl.value : 'region';
        let groups;
        if (uiMode === 'none') {
          groups = (Array.isArray(items) ? items : [])
            .filter(it => Array.isArray(it.coords) && it.coords.length === 2 &&
                          typeof it.coords[0] === 'number' && typeof it.coords[1] === 'number')
            .map(it => ({
              key: `pt:${it.coords[0].toFixed(5)},${it.coords[1].toFixed(5)}`,
              items: [it],
              center: [it.coords[0], it.coords[1]]
            }));
        } else {
          groups = buildAggregateGroups(items);
        }

        groups.forEach((g) => {
          const html = buildAggregatePopupHTML(g.items);
          const repTitle = (g.items[0] && g.items[0].title) ? escapeHTML(g.items[0].title) : escapeHTML(g.key);
          const popupHTML = html || `<div class="popup-wrap media-only"><div class="popup-body"><h2 class="popup-title">${repTitle}</h2></div></div>`;

          const modeEl = document.getElementById('aggregateMode');
          const __mode = modeEl ? modeEl.value : 'region';
          const __icon = (__mode === 'region') ? createAggIcon(g.items.length) : createIcon();
          const marker = L.marker(g.center, { icon: __icon })
            .bindPopup(popupHTML, {
              maxWidth: 520,
              minWidth: 260,
              autoPanPaddingTopLeft: [24, 24],
              autoPanPaddingBottomRight: [24, 24],
              offset: L.point(0, 4),
              className: 'shib-media-only'
            });
          // クラスタクリック時にまとめ表示するために、グループ内アイテムを保持
          marker.options.groupKey = g.key;
          marker.options.__rawItems = g.items;

          const cg = getCountryCluster(g.key);
          cg.addLayer(marker);
          currentMarkers.push(marker);
        });

        // === 入力データ全体が収まる初期範囲に調整 ===
        if (Array.isArray(items) && items.length) {
          const latlngs = items
            .map(it => (Array.isArray(it.coords) && it.coords.length === 2
              ? L.latLng(it.coords[0], it.coords[1]) : null))
            .filter(Boolean);
          if (latlngs.length) {
            const bounds = L.latLngBounds(latlngs);
            map.fitBounds(bounds, { padding: [30, 30], animate: false });
          }
        }

        // 集約表示ではカード帯は一旦非表示に
        const strip = document.getElementById('cardStrip');
        if (strip) strip.style.display = 'none';
      } catch (e) {
        if (!window.__loadAlerted) {
          alert('JSONの読み込みに失敗しました。詳細はコンソールを参照してください。');
          window.__loadAlerted = true;
          setTimeout(() => { window.__loadAlerted = false; }, 2000);
        }
        console.error("Load error in loadCustomMarkers:", e && e.stack ? e.stack : e);
      }
    }

// 追加：地図上のマーカーと保存データを全てクリアする
function clearMarkers() {
  clusterLayerGroup.clearLayers();
  clusterGroupMap.forEach(g => { try { g.clearLayers(); } catch (_) {} });
  clusterGroupMap = new Map();
  currentMarkers.forEach(m => map.removeLayer(m));
  currentMarkers = [];
  addedMarkerSet.clear();
  localStorage.removeItem('ShibmapData');
  document.getElementById('jsonInput').value = '';
  console.log('地図と保存データをクリアしました');
}

window.addEventListener('load', () => {
  // 復元：入力パネルの表示状態
  if (localStorage.getItem('ShibmapPanelCollapsed') === '1') {
    setPanelCollapsed(true);
  } else {
    setPanelCollapsed(false);
  }

  const saved = localStorage.getItem('ShibmapData');
  if (!saved) {
    // 初期表示は日本（東京中心、ズーム5）にフォーカス
    map.setView([35.68, 139.76], 5);
  }
  setTimeout(() => map.invalidateSize(true), 200);
});

if ('serviceWorker' in navigator && (location.protocol === 'https:' || location.hostname === 'localhost' || location.hostname === '127.0.0.1')) {
  navigator.serviceWorker.register('service-worker.js?v=20250727b')
    .then(reg => console.log('Service Worker registered:', reg))
    .catch(err => console.log('Service Worker registration failed:', err));
}


// 新規追加：jsonInputのフォーカス時に画面をスクロールして入力欄を見やすくする（iOS Safari対応）
const input = document.getElementById('jsonInput');
input.addEventListener('focus', () => {
  setTimeout(() => {
    const y = input.getBoundingClientRect().top + window.scrollY - 30;
    window.scrollTo({ top: y, behavior: 'smooth' });
  }, 300);
});

// iOS Safari対策：キーボード表示時にbodyへクラスを付与（クラス自体は残すがtransformはJSで制御）
window.addEventListener('focusin', () => {
  document.body.classList.add('keyboard-open');
});
window.addEventListener('focusout', () => {
  document.body.classList.remove('keyboard-open');
});

// キャッシュ削除後に残る入力文字を防止（初期化）
window.addEventListener('pageshow', (event) => {
  if (event.persisted || (window.performance && performance.getEntriesByType("navigation")[0]?.type === "back_forward")) {
    document.getElementById('jsonInput').value = '';
  }
});

// iOSキーボード高さに応じた動的なinputPanel位置調整（ふらつき対策）
let lastVisualViewportHeight = window.innerHeight;
if (window.visualViewport) {
  window.visualViewport.addEventListener('resize', () => {
    const heightDiff = window.innerHeight - window.visualViewport.height;
    const panel = document.getElementById('inputPanel');
    if (panel && panel.classList.contains('collapsed')) return;
    if (heightDiff > 150) { // おおよそのキーボード出現と判断できる高さ差
      panel.style.bottom = `${heightDiff}px`;
      panel.style.transform = '';
    } else {
      panel.style.bottom = '0px';        // ← 修正: 数値でリセット
      panel.style.transform = 'translateY(0)';
    }
  });
}

  </script>
</body>
  <!-- Shibmap UI finalized as of July 27, 2025. Ready for PWA deployment. -->
  <!-- 修正：画像表示がうまくいかない問題に対応するため、画像のonerrorハンドラでプレースホルダー画像へ切り替えるように明示化 -->
  <!-- 本システムは非営利目的での使用に限ります。CC BY-NCライセンス適用中 -->
</html>
// 集約モードの判定: UIとズームレベルから決定
function getEffectiveAggMode() {
  const modeEl = document.getElementById('aggregateMode');
  const uiMode = modeEl ? modeEl.value : 'region';
  if (uiMode !== 'region') return uiMode; // 'pref' stays as is
  const z = map.getZoom ? map.getZoom() : 5;
  // Align with disableClusteringAtZoom to ensure visual分解
  if (z >= 12) return 'none';   // 個別点（クラスタ無効化閾値と一致）
  if (z >= 7) return 'pref';    // 中ズームは県集約
  return 'region';              // 低ズームは広域
}