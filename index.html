<!DOCTYPE html>
<html lang="ja">
<head>

  <!--
    Shibmap (c) 2025 katagirigouta
    License: CC BY-NC 4.0 International (https://creativecommons.org/licenses/by-nc/4.0/)
    This project is licensed for non-commercial use only.
  -->

  <meta charset="UTF-8" />
  <title>Shibmap</title>
  <link rel="manifest" href="manifest.json" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />

  <!-- Leaflet -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

  <!--（任意）マーカークラスタ：大量件数向け-->
  <!--
  <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.css" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.Default.css" />
  <script src="https://unpkg.com/leaflet.markercluster@1.5.3/dist/leaflet.markercluster.js"></script>
  -->

  <link href="https://fonts.googleapis.com/css2?family=EB+Garamond&family=Noto+Serif+JP:wght@400;600&display=swap" rel="stylesheet" />

  <style>
    :root {
      --bg: #f9f5eb;
      --accent: #4B5F60;
      --link: #2F80ED;
      --tip-h: 10px;  /* 三角高さ */
      --tip-gap: 2px; /* 三角とピンのクリアランス（詰める） */
    }
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      overflow: hidden;
      font-family: 'Noto Serif JP','EB Garamond',serif;
      background: var(--bg);
    }
    #map {
      position: fixed;
      inset: 0;
      width: 100%;
      height: calc(var(--vh, 1vh) * 100); /* ← 修正: setRealVh() で更新 */
    }

    /* iOS: prevent auto-zoom on focused form controls */
    input, textarea, select, button {
      font-size: 16px;
      -webkit-text-size-adjust: 100%;
    }

    /* iOS: respect safe areas and reduce bounce showing white gaps */
    body { padding-top: env(safe-area-inset-top); }
    html, body { overscroll-behavior: none; }

    .leaflet-container {
      background: #e9e4da;
      outline: none;
      width: 100% !important;
      height: 100% !important;
    }

    /* --- tile seam fixes (追加) --- */
    .leaflet-tile {
      background: none !important;
      border: none !important;
    }
    .leaflet-tile-container img { image-rendering: auto; }

    /* AWA風カード（角丸/影/サイズ） */
    .leaflet-container .leaflet-popup-content-wrapper {
      position: relative; /* カスタム三角の基準 */
      padding: 0;           /* メディアは端まで */
      border-radius: 16px;  /* 角を大きめに */
      box-shadow: 0 10px 24px rgba(0,0,0,0.20);
      background: #fff;
    }
    /* --- Popup tip: use centered down-pointing triangle (not diamond) --- */
    .leaflet-container .leaflet-popup-tip-container { display: none !important; }
    .leaflet-container .leaflet-popup-tip { display: none !important; }
    .leaflet-container .leaflet-popup-content-wrapper::after {
      content: "";
      position: absolute;
      left: 50%;
      transform: translateX(-50%);
      bottom: calc(-1 * var(--tip-h));
      width: 0; height: 0;
      border-left: var(--tip-h) solid transparent;
      border-right: var(--tip-h) solid transparent;
      border-top: var(--tip-h) solid #fff;  /* same color as card */
      filter: drop-shadow(0 2px 2px rgba(0,0,0,0.15));
      pointer-events: none;
    }

    /* 本体カードのタイポとサイズ感 */
    .popup-wrap {
      max-width: 360px; /* wider default */
      font-size: 13px;       /* 本文サイズ */
      line-height: 1.55;
    }
    .popup-img, .popup-video {
      width: 100%;
      display: block;
      border-radius: 16px 16px 0 0; /* 上だけ角丸、下は直線 */
      object-fit: cover;
    }
    /* 画像/動画のみ（テキストなし）の共通スタイル */
    .popup-wrap.media-only {
      max-width: 420px;
      border-radius: 16px;     /* 画像/動画だけのとき → 上角丸、下角丸 */
      padding-bottom: 4px;     /* 下はわずかな余白のみ */
    }
    .popup-wrap.media-only .popup-img,
    .popup-wrap.media-only .popup-video {
      border-radius: 16px;     /* メディア単独時は上下とも角丸 */
    }
    
    /* 親のLeafletラッパーを画像/動画のみのときは上辺“角”にする（Chrome/Safariの :has 対応） */
    .leaflet-container .leaflet-popup-content-wrapper:has(.popup-wrap.media-only) {
      border-radius: 16px; /* 画像/動画だけのとき → 上下とも角丸 */
    }
    .leaflet-container .leaflet-popup-content-wrapper:has(.popup-wrap.media-only)::after {
      bottom: calc(-1 * var(--tip-h));
    }
    .popup-wrap img,
    .popup-wrap video {
      display: block;
      margin: 0;
      padding: 0;
    }
    .popup-iframe-wrap {
      width: 100%;
      aspect-ratio: 16 / 9; /* だいたい画像と近い比率 */
      background: #000;
      border-radius: 10px;
      overflow: visible;
      margin-bottom: 8px;
      box-shadow: 0 2px 6px rgba(0,0,0,0.2);
    }
    .popup-iframe-wrap iframe {
      width: 100%;
      height: 100%;
      border: 0;
      display: block;
    }

    /* --- swipeable media gallery --- */
    .media-gallery {
      display: flex;
      overflow-x: auto;
      gap: 8px;
      scroll-snap-type: x mandatory;
      -webkit-overflow-scrolling: touch;
      padding-bottom: 2px;
      margin-bottom: 8px;
    }
    .media-gallery::-webkit-scrollbar { display: none; }
    .media-slide { flex: 0 0 100%; scroll-snap-align: start; }
    .media-slide img,
    .media-slide video,
    .media-slide .popup-iframe-wrap { width: 100%; display: block; }
    .media-dots { display:flex; justify-content:center; gap:6px; margin-top:-4px; margin-bottom:6px; }
    .media-dot { width:6px; height:6px; border-radius:50%; background:#c9c2b2; }
    .media-dot.active { background:#7d7565; }
    .popup-title {
      font-weight: 700;
      font-size: 15px;
      color: var(--accent);
      margin: 8px 0 6px;
    }
    /* 本文エリアの内側余白 */
    .popup-body { padding: 10px 14px 12px; }
    /* メディアがあるときだけカード外枠のパディングをゼロに（上左右ぴったり） */
    .popup-wrap.has-media { padding: 0; }
    .popup-title a.title-link { color: var(--accent); text-decoration: none; }
    .popup-title a.title-link:hover { text-decoration: underline; }
    .tags {
      margin: 4px 0 6px;
      display: flex;
      flex-wrap: wrap;
      gap: 4px;
    }
    .tag {
      background: #ece5d6;
      color: #5a5244;
      padding: 2px 6px;
      border-radius: 6px;
      font-size: 11px;
      line-height: 1.2;
    }
    .popup-link {
      display:inline-block;
      margin-top:4px;
      color: var(--link);
      font-weight:600;
      text-decoration:none;
    }
    .popup-link:hover { text-decoration:underline; }

    .custom-marker-dot {
      width:12px; height:12px; /* 12 + 2px border*2 = 実寸16px（iconSizeと一致） */
      background: var(--accent);
      border-radius:50%;
      border:2px solid #fff;
      box-shadow:0 0 0 1px rgba(0,0,0,0.15);
    }
    .custom-current-location-dot {
      width:14px; height:14px;
      background: #7A1F1F; /* 渋めえんじ色 */
      border-radius:50%;
      border:2px solid #fff;
      box-shadow:0 0 0 1px rgba(0,0,0,0.15);
    }

    .legend {
      position: absolute;
      top: 60px;
      left: 10px;
      background: rgba(255,255,255,0.92);
      backdrop-filter: blur(4px);
      padding: 10px 12px;
      border-radius: 12px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.18);
      font-size: 12px;
      max-width: 240px;
    }
    .legend h1 {
      font-size: 15px;
      margin:0 0 6px;
      font-weight:600;
      color:#333;
    }
    .legend p {
      margin: 0 0 4px;
      color:#555;
      line-height:1.4;
    }
    .legend small { color:#777; font-size:11px; }

    /* 微細なサブピクセル隙間の抑制 */
    .leaflet-tile { outline: 1px solid transparent; }

    /* Leaflet popup: rounded rectangle, proper padding, normal tip arrow */
    .leaflet-container .leaflet-popup-content-wrapper {
      padding: 0; /* 角丸は上の基本設定(16px)を維持する */
    }
    .leaflet-container .leaflet-popup-content {
      margin: 0 !important;
    }

    /* --- force corners to be rounded when popup has only media --- */
    .leaflet-popup.shib-media-only .leaflet-popup-content-wrapper {
      border-radius: 16px !important; /* 画像/動画だけのとき → 上下とも角丸 */
      overflow: visible; /* ← 三角を切らない */
    }
    .leaflet-popup.shib-media-only .leaflet-popup-content {
      padding: 0 !important;
      margin: 0 !important;
    }
    .leaflet-popup.shib-media-only .popup-wrap,
    .leaflet-popup.shib-media-only .popup-media {
      border-radius: 16px !important;
    }
    .leaflet-popup.shib-media-only .popup-img,
    .leaflet-popup.shib-media-only .popup-video {
      border-radius: 16px !important; /* メディア単独時も上下とも角丸 */
    }
    .leaflet-container .leaflet-popup-tip {
      background: white;
    }


    @media (max-width: 640px) {
      .legend { font-size: 11px; }
      .popup-wrap { max-width: 240px; }
      .popup-img { height: 120px; }
      #jsonInput {
        max-height: 30vh;
        resize: vertical;
        overflow: auto;
        margin-bottom: 1em;
        width: 100%;
        box-sizing: border-box;
      }
      #inputPanel button {
        flex-shrink: 0;
        width: auto;
      }
    }

    #jsonInput {
      max-height: 30vh;
      resize: vertical;
      overflow: auto;
      margin-bottom: 1em;
      width: 100%;
      box-sizing: border-box;
      font-size: 16px;
      border: 1px solid #ccc;
      border-radius: 8px;
      background: #fff;
    }
    #jsonInput:focus {
      outline: none;
      border-color: #bbb; /* keep subtle, avoid system blue */
      box-shadow: none;
    }

    textarea {
      width: 100%;
      box-sizing: border-box;
    }

    /* --- inputPanel styles --- */
    #inputPanel {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      max-height: 50%;
      overflow-y: auto;
      background: #fff;
      padding: 10px;
      border-radius: 10px 10px 0 0;
      box-shadow: 0 -2px 6px rgba(0,0,0,0.2);
      z-index: 999;
      display: flex;
      flex-direction: column;
      will-change: transform;
      transition: transform 0.2s ease;
    }
    @supports (env(safe-area-inset-bottom)) {
      #inputPanel {
        padding-bottom: calc(10px + env(safe-area-inset-bottom));
      }
    }

    /* body.keyboard-open #inputPanel {
      transform: translateY(-300px); キーボード高さに応じて調整可能
    } */
    #inputPanel button {
      margin-top: 8px;
      margin-right: 8px;
    }
    #locStatus {
      margin-left: 6px;
      font-size: 12px;
      color: #555;
    }

    .button-row {
      display: flex;
      gap: 8px;
      overflow-x: auto;
      padding-top: 4px;
    }

    .icon-btn {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 32px;
      height: 32px;
      border: none;
      background: none;
      padding: 0;
      margin: 0;
      color: var(--accent);
      cursor: pointer;
    }
    .icon-btn svg { width: 18px; height: 18px; }
    .icon-btn:hover { color: #333; }

    #collapseBtn {
      /* now styled via .icon-btn */
    }
    #collapseBtn:hover {
      color: #333;
    }

    /* --- collapsible input panel & toggle button --- */
    #inputPanel.collapsed {
      transform: translateY(110%);
    }
    #panelToggleFab {
      position: fixed;
      right: 12px;
      bottom: 12px;
      z-index: 1000;
      background: #fff;
      border: 1px solid rgba(0,0,0,0.08);
      border-radius: 999px;
      width: 42px;
      height: 42px;
      box-shadow: 0 2px 6px rgba(0,0,0,0.2);
      display: none; /* shown via .show */
      padding: 0;
    }
    #panelToggleFab.show { display: inline-flex; align-items: center; justify-content: center; }
    @supports (env(safe-area-inset-bottom)) {
      #panelToggleFab { bottom: calc(12px + env(safe-area-inset-bottom)); }
    }
  </style>
  <script>
    // iOS Safariキーボード表示による画面の余白対策
    function setRealVh() {
      let vh = window.innerHeight * 0.01;
      document.documentElement.style.setProperty('--vh', `${vh}px`);
      if (typeof map !== 'undefined') {
        setTimeout(() => map.invalidateSize(true), 100); // ← 強制再描画
      }
    }
    window.addEventListener('resize', setRealVh);
    window.addEventListener('orientationchange', setRealVh);
    setRealVh();

    // Collapsible input panel controls
    function setPanelCollapsed(collapsed) {
      const panel = document.getElementById('inputPanel');
      const fab = document.getElementById('panelToggleFab');
      if (!panel || !fab) return;
      if (collapsed) {
        panel.classList.add('collapsed');
        fab.classList.add('show');
        fab.setAttribute('aria-expanded', 'false');
        localStorage.setItem('ShibmapPanelCollapsed', '1');
      } else {
        panel.classList.remove('collapsed');
        fab.classList.remove('show');
        fab.setAttribute('aria-expanded', 'true');
        localStorage.setItem('ShibmapPanelCollapsed', '0');
      }
    }
    function togglePanel(collapse) {
      setPanelCollapsed(Boolean(collapse));
      // フォーカスの誘導（開いたとき）
      if (!collapse) {
        setTimeout(() => document.getElementById('jsonInput')?.focus(), 80);
      }
      // パネル開閉後に地図サイズを再計算（CSS transition 0.2sに合わせる）
      setTimeout(() => { if (typeof map !== 'undefined') map.invalidateSize(true); }, 220);
    }
  </script>
</head>
<body>
  <div id="map"></div>
  <div id="inputPanel">
      <textarea id="jsonInput" rows="6" placeholder="ここにJSONデータを貼り付け"></textarea>
      <div class="button-row">
        <button id="clearButton" onclick="clearMarkers()">地図をクリア</button>
        <button id="loadButton" onclick="loadCustomMarkers()">地図に表示</button>
        <button id="locateBtn" onclick="locateNow(true)">現在地</button>
        <button id="collapseBtn" class="icon-btn" onclick="togglePanel(true)" title="入力パネルを隠す" style="margin-left:auto">
          <svg viewBox="0 0 24 24" aria-hidden="true"><path fill="currentColor" d="M7.41 8.59 12 13.17l4.59-4.58L18 10l-6 6-6-6z"/></svg>
        </button>
      </div>
      <span id="locStatus"></span>
    </div>
<button id="panelToggleFab" onclick="togglePanel(false)" aria-label="入力を開く" title="入力を開く">
  <svg viewBox="0 0 24 24" aria-hidden="true"><path fill="currentColor" d="M7.41 15.41 12 10.83l4.59 4.58L18 14l-6-6-6 6z"/></svg>
</button>

  <script>
  /*
  例:
  [
    {
      "title": "彩虹邨（Choi Hung Estate）",
      "coords": [22.333189, 114.211905],
      "tags": ["香港", "バスケ"],
      "note": "香港で見つけたawaバスケットコート",
      "image": "images/choihung.jpg",
      "link": "https://example.com"
    }
  ]
  */
    // 追加：現在のマーカーを記録
    let currentMarkers = [];
    let currentLocationMarker = null;
    // ---- 基本マップ ----
    // Popup geometry (must match CSS :root)
    const TIP_H = 10;  // px, --tip-h
    const TIP_GAP = 2; // px, --tip-gap
    const map = L.map('map', {
      minZoom: 0,
      maxZoom: 18,
      worldCopyJump: true,       // 横方向の連続パンを滑らかに
      zoomSnap: 1,               // 小数ズームをやめて白線/カクつきを抑制
      zoomDelta: 1,
      wheelDebounceTime: 25,
      wheelPxPerZoomLevel: 160,
      zoomAnimation: true,
      zoomAnimationThreshold: 1, // ほぼ常にアニメ有効
      fadeAnimation: true
    });

    // 初期表示は世界全体にフィット（ズーム指定や setView は併用しない）
    map.fitWorld({ animate: false });
    // --- clamp latitude only (keep horizontal wrap) ---
    const LAT_MIN = -85.05112878, LAT_MAX = 85.05112878; // Web Mercator 実上限
    let isClamping = false;
    function clampLatImmediate() {
      const c = map.getCenter();
      let lat = c.lat;
      if (lat > LAT_MAX) lat = LAT_MAX;
      else if (lat < LAT_MIN) lat = LAT_MIN;
      if (!isClamping && Math.abs(lat - c.lat) > 1e-6) {
        isClamping = true;
        map.panTo([lat, c.lng], { animate: false });
        isClamping = false;
      }
    }
    // パン中も連続的に補正して“自然に”止める（横はラップ維持）
    map.on('move', clampLatImmediate);
    map.on('zoomend', clampLatImmediate);
    map.on('load', clampLatImmediate);
    map.on('resize', clampLatImmediate);
    // Note: Web Mercator(EPSG:3857) は垂直方向の“無限ラップ”をサポートしないため、南北端では薄い余白が生じます。
    requestAnimationFrame(() => map.invalidateSize(true));

    // ---- 現在地表示 ----
    function locateNow(fromUser = false) {
      const status = document.getElementById('locStatus');
      if (status) status.textContent = '現在地取得中…';

      const isSecure = (location.protocol === 'https:' || location.hostname === 'localhost' || location.hostname === '127.0.0.1');
      if (!isSecure) {
        console.warn('現在地は https または localhost でのみ取得できます。');
        if (fromUser && status) status.textContent = 'https または localhost で利用してください';
        return;
      }

      if (!navigator.geolocation) {
        console.warn('このブラウザはGeolocationに対応していません。');
        if (fromUser && status) status.textContent = 'Geolocationに非対応のブラウザです';
        return;
      }

      const applyPos = (p) => {
        const latlng = [p.coords.latitude, p.coords.longitude];
        if (currentLocationMarker) {
          currentLocationMarker.setLatLng(latlng);
        } else {
          const currentIcon = L.divIcon({
            className: '',
            html: '<div class="custom-current-location-dot"></div>',
            iconSize: [16,16],
            iconAnchor: [8,8],
            popupAnchor: [0,-4]
          });
          currentLocationMarker = L.marker(latlng, { icon: currentIcon })
            .addTo(map)
            .bindPopup('あなたの現在地');
        }
        if (fromUser) map.setView(latlng, Math.max(map.getZoom(), 14));
        if (status) status.textContent = '';
      };

      const onErr = (err) => {
        console.warn('現在地の取得に失敗:', err.message);
        if (fromUser && status) {
          if (err.code === err.PERMISSION_DENIED) status.textContent = '位置情報がブロックされています。サイトの設定から許可してください。';
          else if (err.code === err.TIMEOUT) status.textContent = '取得がタイムアウトしました。屋外で再試行を。';
          else status.textContent = '現在地取得に失敗: ' + err.message;
        }
      };

      // ① 速い（キャッシュ優先）
      navigator.geolocation.getCurrentPosition(applyPos, onErr, {
        enableHighAccuracy: false,
        timeout: 1000,
        maximumAge: 300000 // 5分以内なら即返す
      });

      // ② 高精度で上書き
      navigator.geolocation.getCurrentPosition(applyPos, onErr, {
        enableHighAccuracy: true,
        timeout: 15000,
        maximumAge: 0
      });
    }

    // マップ初期化後に呼び出す
    locateNow(false);

    L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png', {
      attribution: '&copy; OpenStreetMap contributors &copy; CartoDB',
      noWrap: false,
      updateWhenDragging: true,
      updateWhenZooming: true,
      keepBuffer: 2,
      detectRetina: false
    }).addTo(map);

    // ---- カスタムアイコン ----
    function createIcon() {
      return L.divIcon({
        className: '',
        html: '<div class="custom-marker-dot"></div>',
        iconSize: [16,16],
        iconAnchor: [8,8],
        popupAnchor: [0, 0]
      });
    }

    // ---- HTMLエスケープ ----
    function escapeHTML(str='') {
      return str.replace(/[&<>"']/g, s => ({
        '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'
      }[s]));
    }

    const FALLBACK_IMG = 'images/placeholder.jpg'; // 必要なら配置

    // 動画が再生できない（コーデック/アクセス権など）場合のフォールバック
    function videoFallback(videoEl){
      try{
        var parent = videoEl && videoEl.parentNode;
        if (!parent) return; // 親が無ければ何もしない

        var src = videoEl.currentSrc || videoEl.getAttribute('src') || '';
        var poster = videoEl.getAttribute('poster') || '';

        // まずポスター/推測画像を準備
        var img = new Image();
        img.className = 'popup-img';
        img.onload = function(){
          img.style.aspectRatio = img.naturalWidth + '/' + img.naturalHeight;
        };
        img.onerror = function(){
          // 画像もダメならリンクだけを表示
          var a = document.createElement('a');
          a.href = src; a.target = '_blank'; a.rel = 'noopener';
          a.className = 'popup-link'; a.textContent = 'メディアを開く';
          if (parent.contains(videoEl)) {
            try { parent.replaceChild(a, videoEl); } catch(_) { parent.appendChild(a); }
          } else {
            parent.appendChild(a);
          }
        };

        var guessImg = poster || src.replace(/\.[a-z0-9]+(\?.*)?$/i, '.jpg');
        img.src = guessImg;

        // 置換は必ず存在確認してから行う（Leafletの再レンダリング対策）
        if (parent.contains(videoEl)) {
          try { parent.replaceChild(img, videoEl); } catch(_) { parent.appendChild(img); }
        } else {
          parent.appendChild(img);
        }
      }catch(e){ console.error('videoFallback error:', e); }
    }

    // 画像/動画/ギャラリー対応（YouTube/Vimeo/直リンク動画）。
    // ・ギャラリー: item.gallery = [url, url, ...]
    // ・単体: item.video or item.image
    // すべて "自動ミュート再生・playsinline" を優先（ユーザー操作なしで再生可能な範囲）
    function buildMediaHTML(item = {}) {
      const escape = (s='') => escapeHTML(s);
      const fallbackImg = FALLBACK_IMG;

      // URL → メディア要素HTML（単体）
      function buildSingleMedia(url, poster='') {
        const raw = (url || '').toString().trim();
        const rawPoster = (poster || '').toString().trim();
        if (!raw) return '';

        // ---- 正規化：ロジックは “生のURL文字列” で行い、最後に HTML エスケープ ----
        function normalizeURL(u) {
          // ローカル絶対パスは file:/// を付与
          if (location.protocol === 'file:' && /^\/Users\//.test(u)) {
            u = 'file://' + u;
          }
          // 日本語/スペースなどを URL エンコード（スキームや ://, ?, &, = は保持）
          return encodeURI(u);
        }

        const srcFixed = normalizeURL(raw);
        const posterFixed = rawPoster ? normalizeURL(rawPoster) : '';
        const srcAttr = escapeHTML(srcFixed);
        const posterAttr = posterFixed ? ` poster="${escapeHTML(posterFixed)}"` : '';

        // YouTube
        {
          const yt = srcFixed.match(/(?:youtu\.be\/|youtube(?:-nocookie)?\.com\/(?:watch\?v=|embed\/))([A-Za-z0-9_-]{11})/);
          if (yt) {
            const id = yt[1];
            const src = `https://www.youtube-nocookie.com/embed/${id}?rel=0&modestbranding=1&playsinline=1&autoplay=1&mute=1&controls=1`;
            return `<div class="popup-iframe-wrap"><iframe src="${escapeHTML(src)}" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen loading="lazy"></iframe></div>`;
          }
        }

        // Vimeo
        {
          const vm = srcFixed.match(/vimeo\.com\/(?:video\/)?(\d+)/);
          if (vm) {
            const id = vm[1];
            const src = `https://player.vimeo.com/video/${id}?autoplay=1&muted=1&playsinline=1`;
            return `<div class="popup-iframe-wrap"><iframe src="${escapeHTML(src)}" allow="autoplay; fullscreen; picture-in-picture" allowfullscreen loading="lazy"></iframe></div>`;
          }
        }

        // 直接動画（mp4/m4v/webm/ogv/ogg/mov）
        if (/\.(mp4|m4v|webm|ogv|ogg|mov)(\?.*)?$/i.test(srcFixed)) {
          const ext = srcFixed.split('.').pop().toLowerCase().split('?')[0];
          const mimeMap = { mp4:'video/mp4', m4v:'video/mp4', webm:'video/webm', ogv:'video/ogg', ogg:'video/ogg', mov:'video/quicktime' };
          const mime = mimeMap[ext] || 'video/mp4';
          return `<video class="popup-video" src="${srcAttr}" autoplay muted loop playsinline webkit-playsinline controls preload="metadata"${posterAttr}
            onloadedmetadata="this.style.aspectRatio=(this.videoWidth + '/' + this.videoHeight)"
            onerror="videoFallback(this)">
            <source src="${srcAttr}" type="${mime}">
          </video>`;
        }

        // 画像
        if (/\.(apng|avif|gif|jpe?g|png|webp)(\?.*)?$/i.test(srcFixed)) {
          return `<img src="${srcAttr}" alt="" class="popup-img" onload="this.style.aspectRatio=(this.naturalWidth + '/' + this.naturalHeight)" onerror="this.onerror=null;this.src='${fallbackImg}'; this.classList.add('fallback-img');">`;
        }

        // 未判定 → リンク（※ダウンロード誘導はしない）
        return `<a class="popup-link" href="${srcAttr}" target="_blank" rel="noopener">メディアを開く</a>`;
      }

      // ギャラリー優先
      const gallery = Array.isArray(item.gallery) ? item.gallery : null;
      const poster = item.image || '';
      if (gallery && gallery.length) {
        const slides = gallery.map((u, i) => `<div class="media-slide">${buildSingleMedia(u, poster)}</div>`).join('');
        // シンプルなスクロールスナップ + ドット
        const dots = gallery.map((_, i) => `<span class="media-dot${i===0?' active':''}"></span>`).join('');
        // ドットのアクティブ更新（スクロール位置に応じて）
        const id = `gal_${Math.random().toString(36).slice(2)}`;
        const script = `<script>(function(){
          const wrap=document.getElementById('${id}');
          if(!wrap) return; const dots=[...wrap.querySelectorAll('.media-dot')];
          wrap.querySelector('.media-gallery').addEventListener('scroll',function(e){
            const el=e.currentTarget; const idx=Math.round(el.scrollLeft/el.clientWidth);
            dots.forEach((d,i)=>d.classList.toggle('active', i===idx));
          },{passive:true});
        })();<\/script>`;
        return `<div id="${id}"><div class="media-gallery">${slides}</div><div class="media-dots">${dots}</div></div>${script}`;
      }

      // 単体（video優先）
      const video = item.video || '';
      if (video) return buildSingleMedia(video, poster);
      const img = item.image || '';
      if (img) return buildSingleMedia(img);
      return `<img src="${fallbackImg}" alt="" class="popup-img">`;
    }

  </script>
  <script>

// 関数外にこれを追加（表示済みマーカーの記録用）
const addedMarkerSet = new Set();

    function loadCustomMarkers() {
      console.log("Loading custom markers...");
      const input = document.getElementById('jsonInput').value;
      try {
        const items = JSON.parse(input);
        console.log(items);
        localStorage.setItem('ShibmapData', input);

        // 既存マーカー削除
        currentMarkers.forEach(marker => map.removeLayer(marker));
        currentMarkers = [];
        addedMarkerSet.clear();
        const latlngs = [];

        items.forEach((item, index) => {
          // coords形式のみ対応。他の形式（lat, lng等）は非対応
          if (!item.coords || !Array.isArray(item.coords) || item.coords.length !== 2) {
            throw new Error(`スポット ${index + 1} にcoordsが不正です（coords形式のみ対応。他の形式（lat, lng等）は非対応です）`);
          }

          const markerKey = `${item.coords[0]},${item.coords[1]}`;
          if (addedMarkerSet.has(markerKey)) {
            console.log("スキップ: 重複マーカー", markerKey);
            return; // すでに追加済み
          }

          const title = escapeHTML(item.title || '');
          const tags = (item.tags || []).map(t => `<span class="tag">${escapeHTML(t)}</span>`).join('');
          const link = item.link ? escapeHTML(item.link) : '';
          const body = escapeHTML(item.note || '');
          const titleInner = link ? `<a href="${link}" target="_blank" rel="noopener" class="title-link">${title}</a>` : title;
          const hasMedia = Boolean(item.video || item.image || (Array.isArray(item.gallery) && item.gallery.length));
          const isImageOnly = Boolean(item.image && !item.video && !(Array.isArray(item.gallery) && item.gallery.length));
          const mediaHTML = hasMedia ? `<div class="popup-media">${buildMediaHTML(item)}</div>` : '';
          const hasText = Boolean((item.title && item.title.trim()) || (item.note && item.note.trim()) || (Array.isArray(item.tags) && item.tags.length));
          const isMediaOnly = hasMedia && !hasText; // 画像or動画のみ（テキスト無し）

          const popupHTML = `
            <div class="popup-wrap${hasMedia ? ' has-media' : ''}${isMediaOnly ? ' media-only' : ''}">
              ${mediaHTML}
              ${hasText ? `
                <div class="popup-body">
                  ${titleInner ? `<h2 class="popup-title">${titleInner}</h2>` : ''}
                  ${tags}
                  ${body ? `<div class="desc">${body}</div>` : ''}
                </div>
              ` : ''}
            </div>
          `;
          const marker = L.marker(item.coords, { icon: createIcon() })
            .addTo(map)
            .bindPopup(popupHTML, {
              maxWidth: 460,
              minWidth: 260,
              autoPanPaddingTopLeft: [24, 24],
              autoPanPaddingBottomRight: [24, 24],
              offset: L.point(0, 4), // fine-tune: tip meets the outer rim of the pin without piercing
              className: (isMediaOnly ? 'shib-media-only' : 'shib-popup')
            });
          currentMarkers.push(marker);
          console.log("Marker added:", item);
          addedMarkerSet.add(markerKey);
          latlngs.push(item.coords);
        });

        // 追加：読み込んだスポットに地図をフィット。過度なズームは抑える
        if (latlngs.length > 0) {
          const bounds = L.latLngBounds(latlngs);
          const south = Math.max(bounds.getSouth(), LAT_MIN);
          const north = Math.min(bounds.getNorth(), LAT_MAX);
          const west = bounds.getWest();
          const east = bounds.getEast();
          map.fitBounds([[south, west], [north, east]], { padding: [32, 32], maxZoom: 4 });
        }
      } catch (e) {
        alert("JSONの読み込みに失敗しました: " + e.message);
        console.error("JSON parse error:", e);
      }
    }

// 追加：地図上のマーカーと保存データを全てクリアする
function clearMarkers() {
  currentMarkers.forEach(marker => map.removeLayer(marker));
  currentMarkers = [];
  addedMarkerSet.clear();
  localStorage.removeItem('ShibmapData');
  document.getElementById('jsonInput').value = '';
  console.log("地図と保存データをクリアしました");
}

window.addEventListener('load', () => {
  // 復元：入力パネルの表示状態
  if (localStorage.getItem('ShibmapPanelCollapsed') === '1') {
    setPanelCollapsed(true);
  } else {
    setPanelCollapsed(false);
  }

  const saved = localStorage.getItem('ShibmapData');
  if (saved) {
    document.getElementById('jsonInput').value = saved;
    loadCustomMarkers();
  } else {
    // 初期表示は世界全体に。iPhoneでの“拡大され過ぎ”を防止
    map.fitWorld({ padding: [16, 16] });
  }
  setTimeout(() => map.invalidateSize(true), 200);
});

if ('serviceWorker' in navigator) {
  navigator.serviceWorker.register('service-worker.js?v=20250727b')
    .then(reg => console.log('Service Worker registered:', reg))
    .catch(err => console.log('Service Worker registration failed:', err));
}


// 新規追加：jsonInputのフォーカス時に画面をスクロールして入力欄を見やすくする（iOS Safari対応）
const input = document.getElementById('jsonInput');
input.addEventListener('focus', () => {
  setTimeout(() => {
    const y = input.getBoundingClientRect().top + window.scrollY - 30;
    window.scrollTo({ top: y, behavior: 'smooth' });
  }, 300);
});

// iOS Safari対策：キーボード表示時にbodyへクラスを付与（クラス自体は残すがtransformはJSで制御）
window.addEventListener('focusin', () => {
  document.body.classList.add('keyboard-open');
});
window.addEventListener('focusout', () => {
  document.body.classList.remove('keyboard-open');
});

// キャッシュ削除後に残る入力文字を防止（初期化）
window.addEventListener('pageshow', (event) => {
  if (event.persisted || (window.performance && performance.getEntriesByType("navigation")[0]?.type === "back_forward")) {
    document.getElementById('jsonInput').value = '';
  }
});

// iOSキーボード高さに応じた動的なinputPanel位置調整（ふらつき対策）
let lastVisualViewportHeight = window.innerHeight;
if (window.visualViewport) {
  window.visualViewport.addEventListener('resize', () => {
    const heightDiff = window.innerHeight - window.visualViewport.height;
    const panel = document.getElementById('inputPanel');
    if (panel && panel.classList.contains('collapsed')) return;
    if (heightDiff > 150) { // おおよそのキーボード出現と判断できる高さ差
      panel.style.bottom = `${heightDiff}px`;
      panel.style.transform = '';
    } else {
      panel.style.bottom = '0px';        // ← 修正: 数値でリセット
      panel.style.transform = 'translateY(0)';
    }
  });
}

  </script>
</body>
  <!-- Shibmap UI finalized as of July 27, 2025. Ready for PWA deployment. -->
  <!-- 修正：画像表示がうまくいかない問題に対応するため、画像のonerrorハンドラでプレースホルダー画像へ切り替えるように明示化 -->
  <!-- 本システムは非営利目的での使用に限ります。CC BY-NCライセンス適用中 -->
</html>